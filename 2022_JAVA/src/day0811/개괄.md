1. bfs와 dfs
- 이진 완전 트리로 알아본 bfs, dfs
- bfs는 queue자료 구조 활용, dfs는 재귀를 기본적으로 취한다.

2. 비트 마스킹을 활용한 순열 (&, |, << 연산자)
  : << 연산자를 통해 정수를 32칸boolean배열 처럼 사용한다.

3. c++에 있는 Next Permutation 구현하기 (코드블럭을 외우는 것을 추천)
  : 꼭지점을 찾고, 꼭지점 앞에 꺼를, 그 뒤에 것 중 가장 큰 값을 찾아서 바꾸고
  : 바꾼 자리 뒤를 오름차순으로 swap을 통해 정렬해준다.
 
4. bfs와 dfs를 활용하여 풀이한 미로2문제

------

1. 트리탐색 - BFS
2. 트리탐색 - DFS
3. 힙(Heap)
4. 힙 활용 - 우선순위큐 (Priority Queue) -> Comparable, Comparator
5. 완전 검색
6. 순열 응용 - 비트마스킹 순열 (기존 순열 nPn -> n!)
7. 순열 응용 - Next Permutation 구현 (c++에 있는) 
8. 조합 응용 - NextPermutation 활용
9. 부분집합 응용 - binary counting



1. BFS(Breadth First Search)
- 너비 우선 탐색 (너비 : 루트에서 자신까지 오는 데 사용되는 간선 수: 각 노드에서의 높이)
- 너비 우선 탐색은 루트 노드 자식 노드들을 먼저 모두 차례로 방문한 후에,
	방문했던 자식 노드들을 기준으로 하여 다시 해당 노드의 자식 노드들을 차례로 방문하는 방식
- 비선형 자료구조: 多 : 多
- 인접한 노드들에 대해 탐색을 한 후, 차례로 다시 너비우선 탐색을 진행해야 하므로,
	선입선출 형태의 자료구조인 큐를 활용함.
	큐잉 (대기열) 사용!

- 1. 큐생성
- 2. 루트 v를 큐에 삽입
- 3. while (큐가 비어 있지 않은 경우) { <- 방문 대상이 대기열에 있을 때까지
- 	t <- 큐의 첫번째 원소 반환
- 	t 방문
-	for(t와 연결된 모든 간선에 대하여)
-		u <- t의 자식노드
-		u를 큐에 삽입
- end bfs


2. DFS(Depth First Search)
- 깊이 우선 탐색
- 루트 노드에서 nf발하여 gks 방향으로 갈 수 있는 경로가 있는 곳까지 깊이 탐색해 가다가
	더 이상 갈 곳이 없게 되면, 가장 마지막 만났던 갈림길 간선이 있는 노드로 되돌아와서
	다른 방향의 노드로 탐색을 계속 반복하여 결국 모든 노드를 방문하는 순회 방법
- 가장 마지막에 만났떤 갈림길의 노드로 되돌어가서 다시 깊이 우선 탐색을 반복해야 하므로 
	재귀적으로 구현하거나 후입선출 구조의 스택 사용해서 구현한다.

- DFS v(매개변수 : 바뀌는 결정적 요인)
- v 방문
- for (v의 모든 자식노드 w) {
-	DFS(w);

// 비트마스킹
& 조건판단
| 합치기

int하나가 32bit이니까 0,1로 된 boolean 배열과 같다고 생각하고 사용
long도 가능 flag가 64개있다 생각




